#include "leetcode.hpp"

/* 675. 为高尔夫比赛砍树

你被请来给一个要举办高尔夫比赛的树林砍树. 树林由一个非负的二维数组表示，在这个数组中：
  0 表示障碍，无法触碰到.
  1 表示可以行走的地面.
  比 1 大的数 表示一颗允许走过的树的高度.
你被要求按照树的高度从低向高砍掉所有的树，每砍过一颗树，树的高度变为1。
你将从（0，0）点开始工作，你应该返回你砍完所有树需要走的最小步数。
如果你无法砍完所有的树，返回 -1 。
可以保证的是，没有两棵树的高度是相同的，并且至少有一颗树需要你砍。

示例 1:
输入:
[
 [1,2,3],
 [0,0,4],
 [7,6,5]
]
输出: 6

示例 2:
输入:
[
 [1,2,3],
 [0,0,0],
 [7,6,5]
]
输出: -1

示例 3:
输入:
[
 [2,3,4],
 [0,0,5],
 [8,7,6]
]
输出: 6
解释: (0,0) 位置的树，你可以直接砍去，不用算步数

提示: 矩阵大小不会超过 50x50 。
*/

// https://leetcode.com/problems/cut-off-trees-for-golf-event/discuss/107403/C%2B%2B-Sort-%2B-BFS-with-explanation
// 抄的
class Solution {
	struct hpos {
		int height;
		int y, x;
		bool operator<(hpos const& rhs) const
		{
			return height < rhs.height;
		}
	};

	vector<vector<int>> forest;
	vector<char> visit;
	vector<hpos> trees, vq;
	int rows, cols, step;

	int at(int y, int x)
	{
		return y * cols + x;
	}

	int bfs(int h, int w, int eh, int ew)
	{
		int const dir[] = {-1, 0, 1, 0, -1};
		if (h == eh && w == ew)
			return 0;
		vq.clear();
		vq.push_back({0, h, w});
		visit[at(h, w)] = 1;
		memset(visit.data(), 0, rows * cols * sizeof(char));
		for (size_t i = 0; i < vq.size(); ++i) {
			hpos cur = vq[i];
			int s = cur.height + 1;

			for (int d = 0; d < 4; ++d) {
				h = cur.y + dir[d];
				w = cur.x + dir[d + 1];
				if (static_cast<unsigned>(h) >= static_cast<unsigned>(rows)
					|| static_cast<unsigned>(w) >= static_cast<unsigned>(cols)
					|| visit[at(h, w)] || forest[h][w] == 0)
					continue;
				if (h == eh && w == ew)
					return s;
				vq.push_back({s, h, w});
				visit[at(h, w)] = 1;
			}
		}
		return -1;
	}

public:
	int cutOffTree(vector<vector<int>>& _forest)
	{
		int i, h, w;
		forest.swap(_forest);
		rows = static_cast<int>(forest.size());
		if (rows == 0)
			return 0;
		cols = static_cast<int>(forest[0].size());
		visit.resize(rows * cols);
		vq.reserve(rows * cols);

		trees.clear();
		for (h = 0; h < rows; ++h) {
			int const* F = forest[h].data();
			for (w = 0; w < cols; ++w) {
				if (F[w] > 1)
					trees.push_back({F[w], h, w});
			}
		}
		sort(trees.begin(), trees.end());

		i = h = w = step = 0;
		int len = static_cast<int>(trees.size());
		for (; i < len; ++i) {
			int s = bfs(h, w, trees[i].y, trees[i].x);
			if (s == -1)
				return -1;
			step += s;
			h = trees[i].y;
			w = trees[i].x;
		}

		return step;
	}
};

int main()
{
	vector<vector<int>> forest1 = {
		{1, 2, 3},
		{0, 0, 4},
		{7, 6, 5}};
	vector<vector<int>> forest2 = {
		{1, 2, 3},
		{0, 0, 0},
		{7, 6, 5}};
	vector<vector<int>> forest3 = {
		{2, 3, 4},
		{0, 0, 5},
		{8, 7, 6}};
	vector<vector<int>> forest4 = {
		{69438, 55243, 0, 43779, 5241, 93591, 73380},
		{847, 49990, 53242, 21837, 89404, 63929, 48214},
		{90332, 49751, 0, 3088, 16374, 70121, 25385},
		{14694, 4338, 87873, 86281, 5204, 84169, 5024},
		{31711, 47313, 1885, 28332, 11646, 42583, 31460},
		{59845, 94855, 29286, 53221, 9803, 41305, 60749},
		{95077, 50343, 27947, 92852, 0, 0, 19731},
		{86158, 63553, 56822, 90251, 0, 23826, 17478},
		{60387, 23279, 78048, 78835, 5310, 99720, 0},
		{74799, 48845, 60658, 29773, 96129, 90443, 14391},
		{65448, 63358, 78089, 93914, 7931, 68804, 72633},
		{93431, 90868, 55280, 30860, 59354, 62083, 47669},
		{81064, 93220, 22386, 22341, 95485, 20696, 13436},
		{50083, 0, 89399, 43882, 0, 13593, 27847},
		{0, 12256, 33652, 69301, 73395, 93440, 0},
		{42818, 87197, 81249, 33936, 7027, 5744, 64710},
		{35843, 0, 99746, 52442, 17494, 49407, 63016},
		{86042, 44524, 0, 0, 26787, 97651, 28572},
		{54183, 83466, 96754, 89861, 84143, 13413, 72921},
		{89405, 52305, 39907, 27366, 14603, 0, 14104},
		{70909, 61104, 70236, 30365, 0, 30944, 98378},
		{20124, 87188, 6515, 98319, 78146, 99325, 88919},
		{89669, 0, 64218, 85795, 2449, 48939, 12869},
		{93539, 28909, 90973, 77642, 0, 72170, 98359},
		{88628, 16422, 80512, 0, 38651, 50854, 55768},
		{13639, 2889, 74835, 80416, 26051, 78859, 25721},
		{90182, 23154, 16586, 0, 27459, 3272, 84893},
		{2480, 33654, 87321, 93272, 93079, 0, 38394},
		{34676, 72427, 95024, 12240, 72012, 0, 57763},
		{97957, 56, 83817, 45472, 0, 24087, 90245},
		{32056, 0, 92049, 21380, 4980, 38458, 3490},
		{21509, 76628, 0, 90430, 10113, 76264, 45840},
		{97192, 58807, 74165, 65921, 45726, 47265, 56084},
		{16276, 27751, 37985, 47944, 54895, 80706, 2372},
		{28438, 53073, 0, 67255, 38416, 63354, 69262},
		{23926, 75497, 91347, 58436, 73946, 39565, 10841},
		{34372, 69647, 44093, 62680, 32424, 69858, 68719},
		{24425, 4014, 94871, 1031, 99852, 88692, 31503},
		{24475, 12295, 33326, 37771, 37883, 74568, 25163},
		{0, 18411, 88185, 60924, 29028, 69789, 0},
		{34697, 75631, 7636, 16190, 60178, 39082, 7052},
		{24876, 9570, 53630, 98605, 22331, 79320, 88317},
		{27204, 89103, 15221, 91346, 35428, 94251, 62745},
		{26636, 28759, 12998, 58412, 38113, 14678, 0},
		{80871, 79706, 45325, 3861, 12504, 0, 4872},
		{79662, 15626, 995, 80546, 64775, 0, 68820},
		{25160, 82123, 81706, 21494, 92958, 33594, 5243}};
	Solution s;
	ToOut(s.cutOffTree(forest1));
	ToOut(s.cutOffTree(forest2));
	ToOut(s.cutOffTree(forest3));
	ToOut(s.cutOffTree(forest4));
}
